# Category Enumerator Language

Самое важное слово в названии - Simple. Хотя из за большой личной скромности этого слова оно в название не вместилось.

Вообще-то проект не совсем про CEL, но так уж получилось, что ноги выросли именно из него.

## Предназначение

Язык предназначен для компактного и человекопонятного определения списка категорий. Под человеком, в данном случае, понимается достаточно квалифицированный программист, способный ассоциировать категории товаров и их цифровые ID.

## Определения

В дальнейшем изложении, для простоты и определенности, будем считать, что речь идет о магазине, в котором товары привязаны к дереву категорий.

Категория - "деревянная" структура, в которой каждой веточке присвоен уникальный ID и у каждой веточки категории имеется единственный родитель. Под наименованием категории будем иметь ввиду ее цифровой ID, это удобнее, хотя и не так человекопонятно, как "товары со скидкой", например. Хотя, нашему Человеку это должно быть понятно.

Каждый товар может содержать несколько категорий

Категория `0` означает самый верхний уровень дерева категорий. Не имеет смысла, так как отсутствует в реальном мире а вот запись `0*` означает все категории вообще.

## Примеры языковых выражений

`128 or 512* and not 201*` - все товары категории 128, а также все товары категории 512, включая подкатегории, за исключением категории 201 с подкатегориями.
`128 512* not 201*` - то же самое. Некоторые операции можно не писать. Сделано это для исторической совместимости со стилем предыдущей версии языка. Ну и для компактности. Да и просто потому, что так мне нравится :)

## Область применения

В имеющемся у меня приложении, CEL используется в 2-х разные случаях.

- для одного из товаров нужно вычислить, не попадает ли он в нужную нам группу товаров.
- нужно вывести список категорий товаров, соответствующий выражению языка.

Случаи, при ближайшем рассмотрении, можно свести к одному - получить весь список категорий и пользоваться им всегда. Однако, ради спортивного интереса, сделано пара принципиально разных реализаций.

## Описание языка

Язык представляет собой набор тегов, соединенных операциями и сгруппированных скобками. Если между парой тегов нет операции - считаем, что используется операция `OR`. Если между тегами вставлен оператор `NOT` - считаем, что используется конструкция `AND NOT`. Все операции считаются имеющими равный приоритет, если нужно поменять порядок исполнения - используйте скобки.

- тег языка - ID категории. Если за ID следует символ * - имеются ввиду все подкатегории этой категории, включительно.
- круглые скобки `(` и `)` предназначены для определения логического порядка конструкций языка.

В зависимости от исполняющего модуля, смысл операций и тегов может различаться.

- Для вывода списка категорий
    + операция OR - объединяет все категории левого и правого набора.
    + операция AND - пересечение всех категорий левого и правого набора.
    + операция NOT - исключает из набора левого операнда все категории из правого
    + тег определяет набор всех соответствующих категорий.

- Для выяснения принадлежности товара группе
    - операция OR - логическое ИЛИ.
    - операция AND - логическое И.
    - операция NOT - эквивалентно логической конструкции AND NOT
    - тег - логическое значение - принадлежит ли конкретный товар этой группе.

## обработка ошибок

Так как модуль предназначен для вспомогательных вычислений, никакой активной обработки ошибочного ввода не предполагается. Для каждого акта выполнения собирается информация об ошибках в определенной переменной. Результат выполнения, так или иначе, будет выдан в любом случае. После получения результата стоит посмотреть на эту переменную и что-нибудь с ней сделать, если надо...

Однако, существует и вариант запуска и с выкидыванием исключения, при первой же ошибке. Для CEL, imho, ненужная опция, однако для более других приложений может пригодится.

## Реализация.

Собственно, реализация CEL находится в файле `samples/sample_rpn_class.php`.

Основа CEL - класс для трансляции "арифметических" выражений в обратную польскую форму - RPN. Собственно, он и есть само ядро проекта и основное его содержимое. Класс получился довольно универсальный, например, на нем можно достаточно легко создать простой числовой калькулятор - `samples/caclulator.php`. Вычисление функций и тегов выполнено в виде callback-функций, что позволило сделать класс еще более компактным. Довольно удачно вписываются сюда анонимные функции из php5.4++. Заодно он поддерживает унарные операции и операции-суффиксы. Вот кофе варить, пока, не умеет...

Некоторые решения довольно неоднозначны
- Для того, чтобы пользователю можно было не писать операции и все равно получать результат, сделан финт ушами - введена функция _EMPTY_, которая вставляется во все места, где, по логике арифметических выражений, операция обязана была бы стоять. Обработать операцию или выругаться при ее наличии - это дело callback-обработчика.
- унарные операции обрабатываются тем же callback'ом, что и бинарные. Просто первый параметр(левый опреранд) - `false`. В дополнении к этому - дополнительный флаг в параметрах явно указывает на унарную операцию. На этапе выполнения уже нет разницы между унарными операциями и операциями-суффиксами.
- само синтаксическое дерево строится как массив с тегами и операциями. Исполнитель перекладывает теги на стек тегов, а операции выполняет, вызывая соответствующий callback. Функция, обрабатывающая теги обязана преобразовать тег в результат. При этом рализатор обязан уметь отличать теги от результатов выполнения, так как в качестве операндов может приететь и то и то. Тег - массив, в котором присутствует поле `data` - символьное представление тега.