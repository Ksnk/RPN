# RPN

Обратная польская запись

Класс для обслуживания вычисления обычных выражений, записанный в 
строку.

При инициализации вычислителя используются параметры

- `THROW_EXCEPTION_ONERROR` - в случае ошибки срабатывает исключение, а не выводится ошибка
- `SHOW_ERROR` - показывать ошибки в результате  
- `SHOW_DEBUG` - отладка
- `EMPTY_FUNCTION_ALLOWED` - допускается использовать функции без параметров без скобок, как идентификаторы
- `ALLOW_STRINGS` - допускаются изображения строки в одинарных и двойных кавычках
- `ALLOW_REAL` - допускаются изображения вещественных, с точкой - разделителем дробной части.
- `ALLOW_ID` - допускаются неопеределенные заранее идентификаторы.
- `ALLOW_COMMA` - допускаются знаки препинания, запятые, точки с запятыми. Для вызова функции с числом параметров больше 1
- `ALLOW_DOTSTRATCH` - выборка из структуры точкой
- `CASE_SENCITIVE` - все идентификаторы не чувствительны к регистру.

Пример использования вычислителя

    $r = new rpn_class();
    $this->current_rpn = $r;
    $r->option([
      'flags' => 0/**/
          + rpn_class::ALLOW_REAL
          + rpn_class::ALLOW_STRINGS + rpn_class::ALLOW_ID
          + rpn_class::ALLOW_COMMA
          ,
      'operation' => ['+' => 4, '-' => 4, '*' => 5, '/' => 5,],
      'suffix' => ['++' => 1],
      'unop' => ['-' => 1],
      'tagreg' => '\b\d+\b',
      'reserved_words' => ['pi' => 0, 'e' => 0,
          'floor' => 1,
          'pow' => 2,
          'summ' => -1,
      ],

      'evaluateTag' => [$this, '_calcTag'],
      'executeOp' => [$this, '_calcOp'],
    ]);

- `flags` - сумма флагов работы вычислителя
- `operation` - набор используемых операций с приоритетами. Первым выполняется 
операция с наивысшим приоритетом
- `suffix` - постфиксные операции, 
- `unop` - префиксные операции
- `tegreg` - регулярка для посторонних символов
- `reserved_words` - зарезервированные слова, функции без параметров с приоритетами
- `evaluateTag` - функция превычисляющая передаваемый ей тег
- `executeOp` - функция, вычисляющая результат операции.


# Category Enumerator Language

Самое важное слово в названии - Simple. Хотя из за большой личной скромности этого слова оно в название не вместилось.

Вообще-то проект не совсем про CEL, но так уж получилось, что ноги выросли именно из него.

## Предназначение

Язык предназначен для компактного и человекопонятного определения списка категорий. Под человеком, в данном случае, понимается достаточно квалифицированный программист, способный ассоциировать категории товаров и их цифровые ID.

## Определения

В дальнейшем изложении, для простоты и определенности, будем считать, что речь идет о магазине, в котором товары привязаны к дереву категорий.

Категория - "деревянная" структура, в которой каждой веточке присвоен уникальный ID и у каждой веточки категории имеется единственный родитель. Под наименованием категории будем иметь ввиду ее цифровой ID, это удобнее, хотя и не так человекопонятно, как "товары со скидкой", например. Хотя, нашему Человеку это должно быть понятно.

Каждый товар может содержать несколько категорий

Категория `0` означает самый верхний уровень дерева категорий. Не имеет смысла, так как отсутствует в реальном мире а вот запись `0*` означает все категории вообще.

## Примеры языковых выражений

`128 or 512* and not 201*` - все товары категории 128, а также все товары категории 512, включая подкатегории, за исключением категории 201 с подкатегориями.
`128 512* not 201*` - то же самое. Некоторые операции можно не писать. Сделано это для исторической совместимости со стилем предыдущей версии языка. Ну и для компактности. Да и просто потому, что так мне нравится :)

## Область применения

В имеющемся у меня приложении, CEL используется в 2-х разные случаях.

- для одного из товаров нужно вычислить, не попадает ли он в нужную нам группу товаров.
- нужно вывести список категорий товаров, соответствующий выражению языка.

Случаи, при ближайшем рассмотрении, казалось бы, можно свести к одному - получить весь список категорий и пользоваться им всегда. Надо будет подумать над этим...

## Описание языка

Язык представляет собой набор тегов, соединенных операциями и сгруппированных скобками. Если между парой тегов нет операции - считаем, что используется операция `OR`. Если между тегами вставлен оператор `NOT` - считаем, что используется конструкция `AND NOT`. Все операции считаются имеющими равный приоритет, если нужно поменять порядок исполнения - используйте скобки.

- тег языка - ID категории. Если за ID следует символ * - имеются ввиду все подкатегории этой категории, включительно.
- круглые скобки `(` и `)` предназначены для определения логического порядка конструкций языка.

В зависимости от исполняющего модуля, смысл операций и тегов может различаться.

- Для вывода списка категорий
    + операция OR - объединяет все категории левого и правого набора.
    + операция AND - пересечение всех категорий левого и правого набора.
    + операция NOT - исключает из набора левого операнда все категории из правого
    + тег определяет набор всех соответствующих категорий.

- Для выяснения принадлежности товара группе
    - операция OR - логическое ИЛИ.
    - операция AND - логическое И.
    - операция NOT - эквивалентно логической конструкции AND NOT
    - тег - логическое значение - принадлежит ли конкретный товар этой группе.

## обработка ошибок

Так как модуль предназначен для вспомогательных вычислений, никакой активной обработки ошибочного ввода не предполагается. Для каждого акта выполнения собирается информация об ошибках в определенной переменной. Результат выполнения, так или иначе, будет выдан в любом случае. После получения результата стоит посмотреть на эту переменную и что-нибудь с ней сделать, если надо...

Однако, существует и вариант запуска и с выкидыванием исключения, при первой же ошибке. Для CEL, imho, ненужная опция, однако для более других приложений может и пригодится.

## Реализация.

Собственно, реализация CEL находится в файле `samples/sample_rpn_class.php`.

Основа CEL - класс для трансляции "арифметических" выражений в обратную польскую форму - RPN. Собственно, он и есть само ядро проекта и основное его содержимое. Класс получился довольно универсальный, например, на нем можно достаточно легко создать простой числовой калькулятор - `samples/caclulator.php`. Вычисление функций и тегов выполнено в виде callback-функций, что позволило сделать класс еще более компактным. Довольно удачно вписываются сюда анонимные функции из php5.4++. Заодно он поддерживает унарные операции и операции-суффиксы. Вот кофе варить, пока, не умеет...

Некоторые решения довольно неоднозначны
- Для того, чтобы пользователю можно было не писать операции и все равно получать результат, сделан финт ушами - введена функция _EMPTY_, которая вставляется во все места, где, по логике арифметических выражений, операция обязана была бы стоять. Обработать операцию или выругаться при ее наличии - это дело callback-обработчика.
- унарные операции обрабатываются тем же callback'ом, что и бинарные. Просто первый параметр(левый опреранд) - `false`. В дополнении к этому - дополнительный флаг в параметрах явно указывает на унарную операцию. На этапе выполнения уже нет разницы между унарными операциями и операциями-суффиксами.
- само синтаксическое дерево строится как массив с тегами и операциями. Исполнитель перекладывает теги на стек тегов, а операции выполняет, вызывая соответствующий callback. Функция, обрабатывающая теги обязана преобразовать тег в результат. При этом рализатор обязан уметь отличать теги от результатов выполнения, так как в качестве операндов может приететь и то и то. Тег - массив, в котором присутствует поле `data` - символьное представление тега.