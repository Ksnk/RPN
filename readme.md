# Category Enumerator Language

Самое важное слово в названии - Simple. Хотя из за большой личной скромности этого слова оно в название не вместилось.

## Предназначение

Язык предназначен для компактного и человекопонятного определения списка категорий. Под человеком, в данном случае, понимается достаточно квалифицированный программист, способный ассоциировать категории товаров и их цифровые ID.

## Определения

В дальнейшем изложении, для простоты и определенности, будем считать, что речь идет о магазине, в котором товары привязаны к дереву категорий.

Категория - "деревянная" структура, в которой каждой веточке присвоен уникальный ID и у каждой веточки категории имеется единственный родитель. Под наименованием категории будем иметь ввиду ее цифровой ID, это удобнее, хотя и не так человекопонятно, как "товары со скидкой", например. Хотя, нашему Человеку это должно быть понятно.

Каждый товар может содержать несколько категорий

Категория `0` означает самый верхний уровень дерева категорий. Не имеет смысла, так как отсутствует в реальном мире а вот запись `0*` означает все категории вообще.

## Примеры языковых выражений

`128 or 512* and not 201*` - все товары категории 128, а также все товары категории 512, включая подкатегории, за исключением категории 201 с подкатегориями.
`128 512* not 201*` - то же самое. Некоторые операции можно не писать. Сделано это для исторической совместимости со стилем предыдущей версии языка. Ну и для компактности. Да и просто потому, что так мне нравится :)

## Область применения

В имеющемся у меня приложении, CEL используется в 3-х разные случаях.

- для одного из товаров нужно вычислить, не попадает ли он в нужную нам группу товаров.
- нужно вывести список категорий товаров, соответствующий выражению языка.
- нужно вывести список товаров, удовлетворяющих языковой конструкции.

## Описание языка

Язык представляет собой набор тегов, соединенных операциями и сгруппированных скобками. Если между парой тегов нет операции - считаем, что используется операция `OR`. Если между тегами вставлен оператор `NOT` - считаем, что используется конструкция `AND NOT`. Все операции считаются имеющими равный приоритет, если нужно поменять порядок исполнения - используйте скобки.

- тег языка - ID категории. Если за ID следует символ * - имеются ввиду все подкатегории этой категории, включительно.
- круглые скобки `(` и `)` предназначены для определения логического порядка конструкций языка.

В зависимости от исполняющего модуля, смысл операций и тегов может различаться.

- Для вывода списка категорий
    + операция OR - объединяет все категории левого и правого набора.
    + операция AND - пересечение всех категорий левого и правого набора.
    + операция NOT - исключает из набора левого операнда все категории из правого
    + тег определяет набор всех соответствующих категорий.

- Для выяснения принадлежности товара группе
    - операция OR - логическое ИЛИ.
    - операция AND - логическое И.
    - операция NOT - эквивалентно логической конструкции AND NOT
    - тег - логическое значение - принадлежит ли конкретный товар этой группе.

- Для вывода списка товаров происходит построение SQL-условия.
    - операция OR
    - операция AND
    - операция NOT
    - тег - логическое значение - принадлежит ли конкретный товар этой группе.

## обработка ошибок

Так как модуль предназначен для вспомогательных вычислений, никакой активной обработки ошибочного ввода не предполагается. Для каждого акта выполнения собирается информация об ошибках в определенной переменной. Результат выполнения, так или иначе, будет выдан в любом случае. После получения результата стоит посмотреть на эту переменную и что-нибудь с ней сделать, если надо...
